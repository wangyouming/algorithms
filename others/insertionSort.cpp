
void insertionSort(int a[], int n) {
    if (n <= 1) return;
    for (int i = 0; i < n; ++i) {
        int value = a[i];
        int j = i - 1;
        for (; j >= 0; --j) {
            if (a[j] > value) {
                a[j+1] = a[j];
            } else {
                break;
            }
        }
        a[j+1] = value;
    }
}

/*
如果要排序的数据已经是有序的，并不需要搬移任何数据。从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置，所以最好情况时间复杂度是O(n).
如果数组是倒序的，每次插入相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度是O(n^2).
在数组中插入一个数据的平均时间复杂度是O(n)，对于插入排序来说，每次插入操作都相当于在数据中插入一个数据，循环执行n次插入操作，所以平均时间复杂度是O(n^2).
*/

/*
冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。
但是从代码实现来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个.
冒泡排序中的交换操作：
if (a[j] > a[j+1]) {
    int tmp = a[j];
    a[j] = a[j+1];
    a[j+1] = tmp;
    flag = true;
}
插入排序中的移动操作：
if (a[j] > value) {
    a[j+1] = a[j];
} else {
    break;
}
用冒泡排序，需要K次交换操作，每次需要3个赋值语句，所以交换操作总耗时3*K单位时间，而插入排序数据移动操作只需要K个单位时间
*/